
Unix-Linux编程实践教程 & Linux学习

第八章 进程和程序： 编写命令解释器shell

  8.1 进程=运行中的程序
  一个程序是存储在文件中的机器指令序列。一般他是由编译器将源代码编译成二进制个格式的代码。
运行一个程序意味着将这个机器指令序列载入内存然后让处理器（CPU）逐条执行这些指令。
  一个可执行程序是一个机器指令及其数据的序列。一个进程是程序运行时的内存空间和设置。
  数据和程序存储在磁盘文件中，程序在进程中运行。
  进程存在于用户空间。用户空间是存放运行的程序和它们的数据的一部分内存空间。
  进程概念抽象，但它代表了一些非常实际的实体：内存中的一些字节。
  建立一个进程有点像建立一个磁盘文件。内核要找到一些来存放程序指令和数据的空闲内存页。内核
还要建立数据结构来存放相应的内存分配情况和进程属性。

  8.3 shell:进程控制和程序控制的一个工具
  shell是一个管理进程和运行程序的程序。
  主要功能：
  （1）运行程序
  （2）管理输入和输出
  （3）可编程

  8.4 shell是如何运行程序的
  为了要写一个shell,需要学会：
  （1）运行一个程序；
  （2）建立一个进程；
  （3）等待exit()。

  一个程序如何运行另一个程序: 程序调用execvp(progname, arglsit)
  （1）程序调用execvp
  （2）内核从磁盘将程序载入
  （3）内核将arglist复制到进程
  （4）内核调用main（argc,argv）
  注：execvp有两个参数：要运行的程序名和那个程序的命令行参数数组。当程序运行时命令行参数以
argv[]传给程序。注意，将数组的第一个元素置为程序的名称。特别注意，最后一个元素必须是NULL!

  如何建立新的进程： 一个进程调用fork（）来复制自己
  进程拥有程序和当前运行到的位置。进程调用fork,当控制转移到内核中的fork代码后，内核做：
  （1）分配新的内存块和内核数据结构
  （2）复制原来的进程到新的进程
  （3）向运行进程集添加新的进程
  （4）将控制返回给两个进程
  注：父进程和子进程仅仅是进程号PID不一样？
     新的进程从fork返回的地方开始运行，而不是从头开始运行。
     从forkdemo1.c中可以看出，不同的进程。fork的返回值是不同的。在子进程中fork返回0，在父进
程中返回真是的PID。

  父进程如何等待子进程的退出：进程调用wait等待子进程结束。pid = wait（&status）
  在父进程，控制流始于程序的开始，在wait的地方阻塞。在子进程，控制流始于main函数的中部，然后运
行child_code函数，最后调用exit结束。子进程调用exit就像发送一个信号给父进程以唤醒它。
  wait系统调用同时从内核取得退出状态或者信号序列以告诉子进程是如何结束的。
  wait作用：唤醒父进程（通知）
	   通过分析*status的对应位值得出子进程的退出状态（通信）

	git push origin :dev
	git push origin --delete dev 删除对应的远程仓库的dev分支	8:52 PM 12/2/2016
  
  8.6 思考：用进程编程
  execvp/exit 就像 call/return
  （1）call/return （2）exec/exit,fork/exit
  注：exec传递的参数必须是字符串。

	git branch --track dev origin/<branch> OR git branch --set-upstream-to dev origin/<branch>
		 				    指定本地的dev分支与远程origin/<branch>分支的链接	    
										10:57 AM 12/7/2016
	unstaged:
		git checkout -- file		 丢弃file文件的修改
		git checkout .			 丢弃工作区的修改
	staged:
		git reset HEAD file		 将file放到工作区

	Linux修改环境变量，在文件"~/.bashrc"中实现修改,PATH只针对当前用户生效。	
	 注：如果在/etc/bashrc中设置，则为全局用户所使用。（增设alias命令配置同理）	4:19 PM 12/7/2016

	ln -s /../.../filename 		创建"/../.../filename"的硬链接
	rm -rf filename  		删除filename的硬链接（注：参数为"filename"不是"filename/"）
										6:47 PM 12/7/2016

第九章 可编程的shell、shell变量和环境：编写自己的shell

  9.2 什么是以及为什么要使用shell脚本语言
  shell是一个编程语言解释器，这个解释器解释从键盘输入的命令，也解释存储在脚本中的命令序列。	
	
	使用 git push 简短提交代码的配置：
	  git config --global push.default simple 	只提交你当前所在的分支
	  git config --global push.default matching  	提交本地所有的分支
										11:00 AM 12/14/2016
	解决git push每次都需要输入用户名和密码:
	  分析：因为采用的是https方式提交代码，采用ssh方式（只需要在版本库中添加用户的SSH key值实现便捷提交）
   	  git remote rm origin 						    先删除所关联的远程库origin
	  git remote add origin git@github.com:username/repository.git	    关联一个远程库repository
	  git push -u origin master 	
	注：我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分
	   支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。
	  ssh-keygen -t rsa -C "youremail@example.com"		创建SSH Key
	
	git reset --hard commit_id 	回退版本命令				 2:03 PM 12/14/2016
  
  9.3 smshl -- 命令行解析
  分析smshl.c的主函数流程  
	int main()
	{
	  char *cmdline, *prompt, **arglist;
	  int result;
	  void setup();
	  prompt = DFL_PROMPT;
	  setup();

	  while((cmdline = next_cmd(prompt, stdin))!= NULL)
	  {
		if((arglist = splitline(cmdline)) != NULL)
		{
		  result = execute(arglist);
		  freelist(arglist);
		}
		free(cmdline);
	  }
	  return 0;
	}
	(1)next_cmd
	   next_cmd从输入流中读入下一个命令。他调用malloc来分配内存以接受任意长度的命令行。碰到文件结束符，他
	返回NULL.
	(2)splitline 
	   splitline将一个字符串分解为字符串数组，并返回这个数组。他调用malloc来分配内存以接受任意参数个数的
    命令行。这个
	这个数组由NULL标记结束。
	(3)execute
	   execute使用fork,execvp和wait来运行一个命令。execute返回命令的结束状态。
	
  9.4 shell中的流程控制
	shell检查命令的exit状态。exit的状态为0意味着成功，非0意味着失败。
	process程序代码通过三个函数来处理区域问题
	(1)is_control_command返回一个boolean变量告诉process这条命令是脚本语言的一部分还是可执行的命令。
	(2)do_control_command处理关键字if，then,和fi。每个关键字都是区域的界标。这个函数更新状态变量并执行必
	要的操作。
	(3)ok_to_execute根据当前的状态和条件命令的结果返回一个boolean值，说明能否执行当前的命令。
	练习：新加入的controlflow.c文件中，没有对if语句中的else加以处理，留作练习。
  9.5 shell变量：局部和全局
    略乱。
	
  9.6 环境：个性化设置
    Unix允许用户在称之为环境的地方以变量的形式存放这些设置，很多个性化的设置由环境中的变量来记录。
    
	环境（environment）的定义及如何工作：
	  环境是每个程序都可以存取的一个字符串数组。每个数组中的字符串都以valname=value这样的形式出现，数组的
	地址被存放在一个名为environ的全局变量里。 环境就是以environ指向的字符串数组，读环境就是读这个字符串数
	组。改变环境就是改变字符串、改变这个数组中的指针或者将这个全局指针指向其他数组。
	  
	  fork完整的复制父进程，包括代码和数据，数据中包括了环境。exec清除原来进程中的所有代码和数据，插入新程
	 序的代码和数据。只有通过在exexvp传递的参数数据和存储在环境中的字符串可以从旧程序复制到新程序。

第十章  	I/O重定向和管道
  10.3  标准I/O与重定向的若干概念
    概念1： 3个标准文件描述符
	所有的Unix I/O重定向都基于标准数据流的原理。
		标准输入--需要处理的数据流	文件描述符0
		标准输出--结果数据流			文件描述符1
		标准错误输出--错误消息流		文件描述符2
		注：Unix假设文件描述符0,1,2已经被打开，可以分别进行读、写和写的操作。
	  通常通过shell命令行运行Unix系统工具时，stdin,stdout和stderr连接在终端上。因此，工具从键盘读取数据并
	且把输出和错误消息写到屏幕。
	
	重定向I/O的是shell而不是程序。
	  shell并不将重定向标记和文件名传递给程序；
	  重定向可以出现在命令行中的任何地方，并且在重定向标识符周围并不需要空格来区分，它只是一个附加的请求而
	已。甚至像>listing ls 这样的命令也是可以接受的。
	
    概念2： “最低可用文件描述符（Lowest-Available-fd）”原则
	  文件描述符： 它是一个数组的索引号。每个进程都有其打开的一组文件。这些打开的文件被保持在一个数组中。文
	件描述符即为某文件在此数组中的索引。
	  最低可用文件描述符（Lowest-Available-fd）”原则：当打开文件时，为此文件安排的描述符总是数组中最低可用
	位置的索引。
	
	重定向到文件的小结：
		(1)标准输入，输出以及错误输出分别对应于文件描述符0,1,2；
		(2)内核总是使用最低可用文件描述符；
		(3)文件描述符集合通过exec调用传递，且不会被改变。
		shell使用进程通过fork产生子进程与子进程调用exec之间的时间间隔来重定向标准输入，输出到文件。

  10.6  管道编程： 管道是内核中的一个数据队列
	创建管道的函数调用：
    #includ <unistd.h>
	 result = pipe(int array[2])
	 array[0]为读数据端的文件描述符，array[1]为写数据端的文件描述符。	 
	 
    当进程创建一个管道之后，该进程就有了连向管道两端的连接。当这个进程调用fork的时候，它的子进程也得到了这
	两个连向管道的连接。父进程和子进程都可以将数据写到管道的写数据端口，并从读数据端口读出。两进程可以同时
	使用管道，但当一个进程读，另一个写时，管道的利用效率最高。
	
	P319实现了一个pipe,用到fork进程来实现。（体会运用10.5小结的(3)）
	  疑问：既然父进程子进程均可以使用同样的管道，那在各自进程里修改会不会影响另一进程的管道使用？同理对于
	环境，文件描述符等的思考。
	  解答：父进程关闭管道的读文件描述符array[0]后子进程还能读取管道的数据，是因为系统维护的是一个文件的
	文件描述符表的计数，父子进程都各自有指向相同文件的文件描述符，当关闭一个文件描述符时，相应计数减一，当
	这个计数减到0时，文件就被关闭，因此虽然父进程关闭了其文件描述符array[1]，但是这个文件的文件描述符计数
	还没等于0，所以子进程还可以读取。也可以这么理解，父进程和子进程都有各自的文件描述符，因此虽然父进程中关
	闭了array[1]，但是对子进程中的array[1]没有影响。
	  文件表中的每一项都会维护一个引用计数，标识该表项被多少个文件描述符(fd)引用，在引用计数为0的时候，表项
	才会被删除。所以调用close(fd)关闭子进程的文件描述符，只会减少引用计数，但是不会使文件表项被清除，所以父
	进程依旧可以访问。
      最后需要注意，在Linux的pipe管道下，在写端进行写数据时，不需要关闭读端的缓冲文件(即不需要读端的文件描
	述符计数为0)，但是在读端进行读数据时必须先关闭写端的缓冲文件(即写端的文件描述符计数为0)然后才能读取数据。
								转自：http://blog.csdn.net/xy010902100449/article/details/44850965
	
第十一章 连接到近端或远端的进程：服务器与Socket（套接字）

  11.3 bc: Unix中使用的计算器
   将C/S的抽象模型做简单实例演示（tinybc.c）：
	 bc作为客户，在界面上输入信息获取结果；
	 dc作为服务端，在背后提供对输入信息的处理。
	 注: 调用fopen(),将文件名作为参数传递给它；
	     调用fdopen(),将文件描述符作为参数传递给它。
		 使用fdopen()使得对远端的进程的处理就如同处理平常文件一样。
		 
  11.4 popen的功能
    popen打开一个指向进程的带缓冲的连接；           	
	pclose()命令的存在必要性：进程在产生之后必须等待退出运行，否则它将成为僵尸进程。而pclose中调用了wait函
	数来等待进程的结束。
	注：popen()系统调用对于编写网络服务来说是很危险的，因为它直接把一行字符串传给shell。(Page 356)
	
	访问数据：
		方法1： 从文件获取数据
		方法2： 从函数获取数据
		方法3： 从进程获取数据

  11.5 socket: 与远端进程相连
    管道的缺点: 管道在一个进程中被创建，通过fork来实现共享，所以管道只能连接相关的进程，也只能连接同一台主
			   机上的进程。
			   
	重要概念：
		(1)客户和服务器
		(2)主机名和端口
		  运行于英特网上的服务器其实是某台计算机上运行的一个进程。这里计算机被称为主机。机器通常被
		指定一个名字如www.google.com，这被称为该主机的名字。服务器在该主机上拥有一个端口。主机和端口
		的组合才标识了一个服务器。
    

第十二章  连接和协议： 编写Web服务器      --基于socket的客户/服务器系统大多数是类似的

  12.2 三个主要操作
  客户和服务器都是进程。服务器设立服务，然后进入循环接受和处理请求。客户连接到服务器，然后发送，接受或者交换
数据，最后退出。
  主要步骤：
	(1)服务器设立服务；
	(2)客户连接到服务器；
	(3)服务器和客户处理事务。  		
  
  12.3  操作1和操作2：建立连接
   建立服务器端socket
   	(1)穿建一个socket  		socket = socket(PF_INET,SOCK_STREAM,0)
	(2)给socket绑定一个地址    	bind(sock,&addr,sizeof(addr))
	(3)监听接入请求			listen(sock,queue_size)
   建立连接到服务器的连接
	(1)创建一个socket		socket = socket(PF_INET,SOCK_STREAM,0)
	(2)使用该socket连接到服务器	connect(socket,&server_addr,sizeof(serv_addr))

  12.4  操作3：客户/服务器的会话
   DIY(do it yourself) ——服务器接受请求，自己处理工作
   代理——服务器接受请求，然后创建一个新进程来处理工作
	注：考虑Page 368 问题1和问题2  
  
  12.5  编写Web服务器
  webserv.c程序需要改进的地方：
  (1) 僵尸进程的去除
  (2) 缓存溢出保护
  (3) CGI(Common Gateway Interface,通用网关接口)程序需要设置一些环境变量
  (4) HTTP头部可以包含更多的信息 

		  
第十三章  基于数据报（Data gram）的编程：编写许可证服务器
   ——本章中的许可证服务器将实施n用户的限制。也就是说，服务器只允许特定数量的程序实例同时运行。
  
  13.5 数据报socket

  13.9 Unix域socket 

第十四章  线程机制：并发函数的使用

  14.1 同一时刻完成多项任务
  线程相对于函数类似于进程相对于程序，后者为前者提供了运行环境。很多函数可以同时运行，但它们都在相同的进程中。

  


		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		  
		






	